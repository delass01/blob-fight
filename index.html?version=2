<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Blob City Fight</title>
<style>
  body, html {
    margin: 0; padding: 0; overflow: hidden; background: #e0f2f7;
    font-family: Arial, sans-serif;
  }
  canvas {
    display: block; margin: 0 auto; background: #a3d1ff;
    border: 2px solid #005f99;
  }
  #instructions {
    position: fixed; top: 10px; left: 10px; background: rgba(255,255,255,0.8);
    padding: 10px; border-radius: 5px;
    max-width: 300px;
    font-size: 14px;
  }
</style>
</head>
<body>
<div id="instructions">
  <strong>Blob City Fight</strong><br />
  Contrôlez votre blob avec les flèches (PC) ou le joystick tactile (mobile).<br />
  Mangez les blobs plus petits, évitez les plus gros !<br />
  Les zombies (IA) errent et chassent.<br />
</div>
<canvas id="gameCanvas" width="800" height="600"></canvas>

<script>
// --- CONFIGURATION ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const MAP_WIDTH = canvas.width;
const MAP_HEIGHT = canvas.height;

const PLAYER_SPEED = 3;
const BOT_SPEED = 2;
const INITIAL_BLOB_SIZE = 20;
const SIZE_INCREMENT = 4; // taille gagnée quand on mange un blob

// --- UTILITAIRES ---
function distance(x1, y1, x2, y2) {
  return Math.hypot(x2 - x1, y2 - y1);
}

function clamp(val, min, max) {
  return Math.min(max, Math.max(min, val));
}

// --- BLOB CLASS ---
class Blob {
  constructor(id, x, y, size, color, isPlayer=false) {
    this.id = id;
    this.x = x;
    this.y = y;
    this.size = size;
    this.color = color;
    this.isPlayer = isPlayer;
    this.speed = isPlayer ? PLAYER_SPEED : BOT_SPEED;
    this.dirX = 0;  // direction x [-1,1]
    this.dirY = 0;  // direction y [-1,1]
  }

  draw() {
    // corps du blob (cercle)
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.ellipse(this.x, this.y, this.size, this.size * 0.8, 0, 0, Math.PI*2);
    ctx.fill();

    // yeux
    ctx.fillStyle = 'white';
    let eyeOffsetX = this.size * 0.4;
    let eyeOffsetY = -this.size * 0.3;
    let eyeRadius = this.size * 0.15;
    ctx.beginPath();
    ctx.ellipse(this.x - eyeOffsetX, this.y + eyeOffsetY, eyeRadius, eyeRadius*1.3, 0, 0, Math.PI*2);
    ctx.ellipse(this.x + eyeOffsetX, this.y + eyeOffsetY, eyeRadius, eyeRadius*1.3, 0, 0, Math.PI*2);
    ctx.fill();

    // pupilles (regard dans la direction de déplacement)
    ctx.fillStyle = 'black';
    let pupilleOffset = eyeRadius * 0.5;
    let lookX = this.dirX * pupilleOffset;
    let lookY = this.dirY * pupilleOffset;
    ctx.beginPath();
    ctx.ellipse(this.x - eyeOffsetX + lookX, this.y + eyeOffsetY + lookY, eyeRadius*0.5, eyeRadius*0.7, 0, 0, Math.PI*2);
    ctx.ellipse(this.x + eyeOffsetX + lookX, this.y + eyeOffsetY + lookY, eyeRadius*0.5, eyeRadius*0.7, 0, 0, Math.PI*2);
    ctx.fill();
  }

  move(dx, dy) {
    this.x = clamp(this.x + dx, this.size, MAP_WIDTH - this.size);
    this.y = clamp(this.y + dy, this.size, MAP_HEIGHT - this.size);
  }

  updateDirection(dx, dy) {
    this.dirX = dx;
    this.dirY = dy;
    // normaliser la direction si pas nul
    if (dx !== 0 || dy !== 0) {
      const len = Math.hypot(dx, dy);
      this.dirX /= len;
      this.dirY /= len;
    }
  }
}

// --- GAME STATE ---
let blobs = [];
let playerBlob = null;

// Crée un blob à une position aléatoire, sauf celle du joueur
function randomPosition(margin=50) {
  return {
    x: Math.random() * (MAP_WIDTH - 2*margin) + margin,
    y: Math.random() * (MAP_HEIGHT - 2*margin) + margin
  };
}

// --- INITIALISATION ---
function initGame() {
  blobs = [];

  // Crée joueur
  const pos = randomPosition();
  playerBlob = new Blob('player', pos.x, pos.y, INITIAL_BLOB_SIZE, '#0077cc', true);
  blobs.push(playerBlob);

  // Crée bots IA
  for (let i=1; i<=3; i++) {
    let posBot = randomPosition();
    let color = `hsl(${Math.random()*360}, 70%, 50%)`;
    blobs.push(new Blob('bot'+i, posBot.x, posBot.y, INITIAL_BLOB_SIZE, color));
  }
}

initGame();

// --- CONTROLES ---
const keys = {up:false, down:false, left:false, right:false};
window.addEventListener('keydown', (e) => {
  if (e.key === 'ArrowUp') keys.up = true;
  else if (e.key === 'ArrowDown') keys.down = true;
  else if (e.key === 'ArrowLeft') keys.left = true;
  else if (e.key === 'ArrowRight') keys.right = true;
});
window.addEventListener('keyup', (e) => {
  if (e.key === 'ArrowUp') keys.up = false;
  else if (e.key === 'ArrowDown') keys.down = false;
  else if (e.key === 'ArrowLeft') keys.left = false;
  else if (e.key === 'ArrowRight') keys.right = false;
});

// --- TOUCH CONTROLS (simple joystick) ---
let touchStartX = 0;
let touchStartY = 0;
let touchDirX = 0;
let touchDirY = 0;

canvas.addEventListener('touchstart', (e) => {
  const t = e.touches[0];
  touchStartX = t.clientX;
  touchStartY = t.clientY;
});
canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  const t = e.touches[0];
  let dx = t.clientX - touchStartX;
  let dy = t.clientY - touchStartY;
  const dist = Math.hypot(dx, dy);
  if (dist > 0) {
    touchDirX = dx / dist;
    touchDirY = dy / dist;
  }
});
canvas.addEventListener('touchend', (e) => {
  touchDirX = 0;
  touchDirY = 0;
});

// --- BOT IA LOGIC ---
function botBehavior(bot) {
  // Simple AI : cherche un blob plus petit pour chasser, sinon errer
  let target = null;
  let minDist = Infinity;

  for (const b of blobs) {
    if (b.id === bot.id) continue; // pas se cibler soi-même
    if (b.size < bot.size) {
      let d = distance(bot.x, bot.y, b.x, b.y);
      if (d < minDist) {
        minDist = d;
        target = b;
      }
    }
  }

  if (target) {
    // se diriger vers la cible
    let dx = target.x - bot.x;
    let dy = target.y - bot.y;
    let dist = Math.hypot(dx, dy);
    if (dist > 0) {
      bot.updateDirection(dx, dy);
      bot.move(bot.dirX * bot.speed, bot.dirY * bot.speed);
    }
  } else {
    // errer aléatoirement
    if (Math.random() < 0.02) {
      let angle = Math.random() * Math.PI*2;
      bot.updateDirection(Math.cos(angle), Math.sin(angle));
    }
    bot.move(bot.dirX * bot.speed * 0.5, bot.dirY * bot.speed * 0.5);
  }
}

// --- COLLISION & MANGER ---
function checkEating() {
  for (let i = blobs.length -1; i >= 0; i--) {
    for (let j = blobs.length -1; j >=0; j--) {
      if (i === j) continue;
      let a = blobs[i];
      let b = blobs[j];

      // blob plus gros mange blob plus petit si proches et taille assez grande
      if (a.size > b.size * 1.2) {
        let dist = distance(a.x, a.y, b.x, b.y);
        if (dist < a.size) {
          // Mange : blob a grossit, b disparaît
          a.size += SIZE_INCREMENT;
          blobs.splice(j,1);
          // Si c'est le joueur qui a mangé, rien à faire ici
          if (b.id === playerBlob.id) {
            alert('Vous avez été mangé ! Partie terminée.');
            initGame();
            return;
          }
          if (a.id === playerBlob.id) {
            // bonus ou effets futurs ?
          }
        }
      }
    }
  }
}

// --- DESSIN MAP ---
function drawMap() {
  // sol (bleu clair)
  ctx.fillStyle = '#a3d1ff';
  ctx.fillRect(0, 0, MAP_WIDTH, MAP_HEIGHT);

  // routes (grises)
  ctx.fillStyle = '#ccc';
  const roadWidth = 60;
  // verticales
  for(let x=roadWidth/2; x<MAP_WIDTH; x += 200) {
    ctx.fillRect(x - roadWidth/2, 0, roadWidth, MAP_HEIGHT);
  }
  // horizontales
  for(let y=roadWidth/2; y<MAP_HEIGHT; y += 200) {
    ctx.fillRect(0, y - roadWidth/2, MAP_WIDTH, roadWidth);
  }

  // bâtiments simples (rectangles)
  ctx.fillStyle = '#668899';
  for(let x=0; x<MAP_WIDTH; x+=200) {
    for(let y=0; y<MAP_HEIGHT; y+=200) {
      if (Math.random() < 0.3) {
        ctx.fillRect(x + 20, y + 20, 100, 80);
      }
    }
  }
}

// --- GAME LOOP ---
function gameLoop() {
  // déplacement joueur
  let dx = 0, dy = 0;
  if (keys.up) dy -= 1;
  if (keys.down) dy += 1;
  if (keys.left) dx -= 1;
  if (keys.right) dx += 1;

  // joystick tactile
  if (touchDirX !== 0 || touchDirY !== 0) {
    dx = touchDirX;
    dy = touchDirY;
  }

  // normaliser
  if (dx !== 0 || dy !== 0) {
    let len = Math.hypot(dx, dy);
    dx /= len;
    dy /= len;
  }
  playerBlob.updateDirection(dx, dy);
  playerBlob.move(dx * playerBlob.speed, dy * playerBlob.speed);

  // comportement IA bots
  for (const b of blobs) {
    if (!b.isPlayer) {
      botBehavior(b);
    }
  }

  // check collisions et manger
  checkEating();

  // dessin
  drawMap();

  for (const b of blobs) {
    b.draw();
  }

  // Affiche taille du joueur
  ctx.fillStyle = 'black';
  ctx.font = '18px Arial';
  ctx.fillText(`Taille: ${Math.round(playerBlob.size)}`, 10, 590);

  requestAnimationFrame(gameLoop);
}

gameLoop();
</script>
</body>
</html>
